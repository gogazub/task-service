# Task Service

Лёгкий сервис обработки задач на Go: очередь, пул воркеров, ретраи с экспоненциальным бэкоффом и джиттером, статусы задач, HTTP-интерфейс для постановки и health-проверки, корректное завершение (graceful shutdown). Только стандартная библиотека.

---

## Возможности

- `POST /enqueue` - поставить задачу в буферизованную очередь.
- `GET /healthz` - простой healthcheck (200 OK, пока сервис жив).
- Пул воркеров `WORKERS` - конкурентная обработка задач.
- Ретраи с **экспоненциальным бэкоффом** и **джиттером** до `max_retries` раз.
- Статусы задач: `queued → running → done | failed` (in-memory).
- **Graceful shutdown**: перестаём принимать новые и ретраи, дожидаемся **только текущих** задач.

---

## Быстрый старт

```bash
export WORKERS=4
export QUEUE_SIZE=64
export BACKOFF_BASE_MS=100
export BACKOFF_MAX_MS=5000
go run ./cmd/server/main.go
```

Проверка:
```bash
curl -i http://localhost:8080/healthz
```

Постановка задач:
```bash
curl -i -X POST http://localhost:8080/enqueue \
  -H "Content-Type: application/json" \
  -d '{"id":"t1","payload":"any","max_retries":3}'
```

---

## Конфигурация (ENV)

- `WORKERS` - количество воркеров (по умолчанию `4`).
- `QUEUE_SIZE` - ёмкость очереди задач (по умолчанию `64`).
- `BACKOFF_BASE_MS` - базовая задержка (по умолчанию `100` мс).
- `BACKOFF_MAX_MS` - максимальная задержка (по умолчанию `5000` мс).

---


## Публичное API

### `POST /enqueue`

Тело запроса:
```json
{ "id": "t1", "payload": "any", "max_retries": 3 }
```

Ответы:
- `202 Accepted` + `{"id":"t1"}` - задача принята (`queued`).
- `400 Bad Request` - невалидный JSON/поля.
- `409 Conflict` - такой `id` уже есть.
- `503 Service Unavailable` - очередь переполнена (задача не принята).

### `GET /healthz`

- `200 OK` - сервис жив.

---

## Детали реализации

### Worker Pool
- Читает задачи из `ReadyQueue` и помечает `running` на старте.
- Обработчик по умолчанию «симулирует» работу (100–500 мс, ~20% ошибок)
- После выполнения:
  - успех - `done`;
  - ошибка и `attempt < max_retries` - бэкофф + джиттер - план в `RetryManager` - статус `queued`;
  - ошибка и попыток не осталось -`failed`.
- **Штрих к graceful:** после каждой задачи воркер проверяет `ctx.Done()` и, если отмена пришла, **выходит** не беря следующую - это гарантирует «доделать текущую, не стартовать новые».

### Retry Manager (min-heap + один `time.Timer`)
- Хранит `(runAt, seq, task)` в мин-куче (раньше - выше).
- Всегда держит **один** таймер на ближайший дедлайн. По срабатыванию - возвращает задачу в `ReadyQueue`.
- Отмена через контекст - петля аккуратно завершается, оставшиеся отложенные задачи **не** переводятся в `ReadyQueue` (соответствует «не стартовать новые»).

### Бэкофф и джиттер
```text
delay = min( BASE * 2^(attempt-1), MAX ), затем полное рандомное [0..delay]
```
Это снижает синхронные пики повторов и помогает системам стабилизироваться.

### Статусы
- `queued` - задача в очереди/на ретрае;
- `running` - взята воркером;
- `done` - успешно выполнена;
- `failed` - исчерпала ретраи или упала окончательно.

Хранятся в `MemStore`.

---

## Тесты

Интеграционные (std lib, `httptest.Server`):
- healthcheck (200);
- успешная обработка пачки задач;
- ретраи до успеха;
- исчерпание ретраев → `failed`;
- переполненная очередь → `503` и откат статуса;
- graceful shutdown: текущая задача завершается (`done`), следующая остаётся `queued`.

Запуск:
```bash
go test -v -race ./...
```
